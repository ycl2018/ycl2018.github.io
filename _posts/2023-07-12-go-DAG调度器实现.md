---
title: goå®žçŽ°å¤šä»»åŠ¡å¹¶å‘DAGè°ƒåº¦å™¨
date: 2023-07-12 13:00:12 +0800
categories: [golang,ä¸ªäººå¼€æºé¡¹ç›®]
tags: [golang,dagè°ƒåº¦,ä½œè€…å¼€æº]     # TAG names should always be lowercase
description: ç”¨golangå®žçŽ°å¤šä»»åŠ¡ä¾èµ–è°ƒåº¦å™¨ï¼Œè‡ªåŠ¨æŒ‰ç…§ä»»åŠ¡çš„ä¾èµ–å…³ç³»å¹¶å‘æ‰§è¡Œï¼Œé™ä½Žä»»åŠ¡æ•´ä½“å»¶æ—¶ã€‚
pin: false
image: assets/imgs/preview/graph.png
---

> æœ¬æ–‡ä»‹ç»çš„DAGè°ƒåº¦å·¥å…·å·²å¼€æºï¼Œæ¬¢è¿Žä½¿ç”¨ã€åé¦ˆã€PRã€è®°å¾—ç•™ä¸‹å°æ˜Ÿæ˜Ÿï½žï¼š[å¼€æºDAGè°ƒåº¦å™¨](https://github.com/ycl2018/dag-run)

## ä¸€ã€ä»€ä¹ˆæ˜¯DAGè°ƒåº¦å™¨

DAG(Directed Acyclic Graph)ï¼Œä¸­æ–‡åæ˜¯â€œæœ‰å‘æ— çŽ¯å›¾â€ï¼Œåœ¨è®¡ç®—æœºä¸­æ˜¯ä¸€ç§å›¾æ•°æ®ç»“æž„ã€‚DAGé€šå¸¸ç”¨æ¥æè¿°ä¸€ç³»åˆ—å…³ç³»çš„ä»»åŠ¡ï¼ˆèŠ‚ç‚¹ï¼‰çš„å‰åŽä¾èµ–é¡ºåºã€‚æˆ‘ä»¬æ—¥å¸¸ç”Ÿæ´»ä¸­ä¹Ÿæœ‰å¾ˆå¤šè¿™æ ·çš„ä¾‹å­ï¼Œæ‹¿ç®€å•çš„åšé¥­æ´»åŠ¨ä½œä¸ºä¾‹å­ï¼Œåšé¥­å¯ä»¥æ‹†åˆ†ä¸ºæ´—èœã€æ´—é”…ã€åˆ‡èœã€æ·˜ç±³ã€ç…®é¥­ã€ç‚’èœã€åƒé¥­ç­‰é˜¶æ®µï¼Œè¿™ä¸ªæ´»åŠ¨å¯ä»¥ç”¨å›¾å½¢åŒ–çš„DAGæ¥æè¿°ï¼š

![dagç¤ºä¾‹](assets/imgs/dag-cook.png)

ç”¨dagå›¾å½¢ä¸­å¯ä»¥æ¸…æ™°çš„çœ‹å‡ºæ´—èœã€æ´—é”…ã€æ·˜ç±³ä¹‹é—´æ˜¯å¯ä»¥â€œå¹¶è¡Œâ€çš„ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å…ˆåŽé¡ºåºä¾èµ–ï¼Œä½†ç‚’èœå¿…é¡»ç­‰æ´—é”…å’Œåˆ‡èœä¸¤ä¸ªæ´»åŠ¨å®Œæˆæ‰èƒ½è¿›è¡Œã€‚ç±»ä¼¼åƒé¥­ä¹Ÿéœ€è¦ç‚’èœå’Œç…®é¥­å®Œæˆä¹‹åŽæ‰èƒ½å¼€å§‹ã€‚

çŽ°å®žçš„å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå°¤å…¶æ˜¯åšæœåŠ¡ç«¯å¼€å‘å·¥ä½œçš„åŒå­¦ï¼Œå¾€å¾€ä¼šåœ¨ä¸šåŠ¡é€»è¾‘ä¸­æ‰§è¡Œå¤šä¸ªä»»åŠ¡ï¼ˆå¦‚è¿›è¡Œè€—æ—¶çš„RPCè°ƒç”¨ï¼‰ï¼Œè¿™äº›ä»»åŠ¡ä¹‹é—´æœ‰çš„å¯ä»¥å¹¶è¡Œï¼Œæœ‰çš„æœ‰ä¾èµ–å…³ç³»éœ€è¦ä¸²å½¢æ‰§è¡Œã€‚åœ¨goè¯­è¨€ä¸­ï¼Œéœ€è¦å¹¶è¡Œçš„ä»»åŠ¡æˆ‘ä»¬å¯ä»¥ç»™æ¯ä¸ªä»»åŠ¡å¯åŠ¨ä¸€ä¸ªgoroutineæ¥æ‰§è¡Œï¼Œåœ¨æœ‰ä¾èµ–çš„ä»»åŠ¡å¼€å§‹å‰ç”¨`sync.WaitGroup.Wait()`æ¥è¿›è¡ŒåŒæ­¥ã€‚å¦‚æžœä»»åŠ¡æ•°é‡è¾ƒå°‘çš„è¯ï¼Œè¿™ç§å†™æ³•æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œä½†å¦‚æžœä¸€ä¸ªä»»åŠ¡å­˜åœ¨å¤§é‡çš„RPCè°ƒç”¨ï¼Œæˆ–è€…æŸäº›ä»»åŠ¡éœ€è¦å¯é…ç½®åŒ–ä»»åŠ¡ä¾èµ–å…³ç³»æ—¶ï¼Œè¿™ç§ç¡¬ç¼–ç çš„æ–¹å¼å°±æ˜¾å¾—æœ‰äº›åŠ›ä¸ä»Žå¿ƒã€‚

æˆ‘ä»¬å¯ä»¥å‚è€ƒDAGå›¾ï¼Œæ¥æŠ½è±¡å‡ºä¸€ä¸ªå¯ä»¥è‡ªåŠ¨åˆ†æžè¦æ‰§è¡Œä»»åŠ¡çš„ä¾èµ–å…³ç³»ï¼Œç„¶åŽè‡ªåŠ¨åŒ–çš„è°ƒåº¦ä»»åŠ¡ï¼Œæ— ä¾èµ–çš„ä»»åŠ¡ä¹‹é—´å¹¶å‘æ‰§è¡Œï¼Œå­˜åœ¨ä¾èµ–çš„ä»»åŠ¡ä¹Ÿè‡ªåŠ¨è¿›è¡ŒåŒæ­¥ï¼Œä¼šå¤§å¤§ç®€åŒ–æˆ‘ä»¬çš„å¼€å‘å·¥ä½œã€‚

## äºŒã€å¦‚ä½•å®žçŽ°ä¸€ä¸ªDAGè°ƒåº¦å™¨

### 2.1 å®žçŽ°ä¸€ä¸ªå›¾æ•°æ®ç»“æž„

è¦å®žçŽ°DAGï¼Œéœ€è¦é¦–å…ˆå®žçŽ°ä¸€ä¸ªå›¾çš„æ•°æ®ç»“æž„æ¥æè¿°ä»»åŠ¡ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚æ¯ä¸ªä»»åŠ¡èŠ‚ç‚¹æˆ‘ä»¬ä¸€èˆ¬è¡¨ç¤ºä¸ºNodeï¼Œä¸ºäº†é€šç”¨æ€§è€ƒè™‘ï¼Œæˆ‘ä»¬å®šä¹‰`Node`ä¸ºä¸€ä¸ªæŽ¥å£ï¼Œåªæœ‰ä¸€ä¸ª`Name()`æ–¹æ³•ï¼Œè¡¨ç¤ºä»»åŠ¡çš„åç§°ã€‚

```go
type Node interface {
    Name() string
}
```

DAGä¸­é™¤äº†ç‚¹ï¼Œè¿˜éœ€è¦æœ‰è¾¹ï¼Œç”¨æ¥æè¿°èŠ‚ç‚¹ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼Œè¿™é‡Œæˆ‘ä»¬ç®€å•çš„ä½¿ç”¨mapç»“æž„è¡¨ç¤ºå³å¯ï¼Œmapçš„keyå’Œvaluesåˆ†åˆ«è¡¨ç¤ºæœ‰ä¾èµ–å…³ç³»çš„èŠ‚ç‚¹åŠå…¶åŽç»§èŠ‚ç‚¹ï¼Œæœ‰äº†è¾¹å’Œç‚¹çš„å®šä¹‰ï¼Œæˆ‘ä»¬çš„DAGå›¾å¯ä»¥å®šä¹‰ä¸ºï¼š

```go
type Graph struct {
    Nodes []Node
    Edges map[Node][]Node
}
```

æŽ¥ä¸‹æ¥æˆ‘ä»¬ç»™å›¾ç»“æž„æ·»åŠ ä¸Š`AddNode`,`AddEdge`çš„å‡½æ•°ï¼š

```go
func (g *Graph) AddNode(n Node) {
    g.Nodes = append(g.Nodes, n)
}

func (g *Graph) AddEdge(from Node, to Node) {
    g.Edges[from] = append(g.Edges[from], to)
}
```

æŽ¥ä¸‹æ¥ç¨å¾®å¤æ‚çš„ä¸€æ­¥ï¼Œæ—¢ç„¶æˆ‘ä»¬çš„å›¾DAGè¡¨ç¤ºçš„æ˜¯â€œæœ‰å‘æ— çŽ¯â€œå›¾ï¼Œæ‰€ä»¥å½“å›¾ä¸­çš„ç‚¹å’Œè¾¹éƒ½æ·»åŠ å®Œä¹‹åŽï¼Œéœ€è¦ç¡®è®¤å›¾ä¸­æ˜¯æ²¡æœ‰çŽ¯å­˜åœ¨çš„ï¼Œè¿™é‡Œéœ€è¦ç”¨åˆ°å›¾çš„éåŽ†çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ·±åº¦ä¼˜å…ˆ/å¹¿åº¦ä¼˜å…ˆéåŽ†æ¥å®žçŽ°ï¼Œä¸ºäº†æ•ˆçŽ‡çš„è€ƒé‡ï¼Œæˆ‘ä»¬è¿™é‡Œé‡‡ç”¨éžé€’å½’å½¢å¼çš„å¹¿åº¦ä¼˜å…ˆéåŽ†ç®—æ³•ã€‚ç»´æŠ¤ä¸€ä¸ªå…¥åº¦ä¸º0çš„èŠ‚ç‚¹é›†åˆï¼šä»Žé›†åˆä¸­å–å‡ºèŠ‚ç‚¹ï¼ŒæŸ¥æ‰¾å…¶åŽç»§èŠ‚ç‚¹ï¼Œå°†åŽç»§èŠ‚ç‚¹çš„å…¥åº¦-1ï¼Œå¦‚æžœåŽç»§èŠ‚ç‚¹çš„å…¥åº¦å˜ä¸º0ï¼Œåˆ™å°†å…¶æ·»åŠ åˆ°å…¥åº¦ä¸º0çš„èŠ‚ç‚¹é›†åˆä¸­ï¼ŒåŒæ—¶è®°å½•éåŽ†è¿‡çš„èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œé‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°æ²¡æœ‰å…¥åº¦ä¸º0çš„é›†åˆä¸ºç©ºã€‚å¦‚æžœéåŽ†åˆ°çš„èŠ‚ç‚¹ä¸ªæ•°å°äºŽå›¾ä¸­èŠ‚ç‚¹çš„æ€»æ•°ï¼Œåˆ™è¯´æ˜Žå›¾ä¸­å­˜åœ¨çŽ¯ã€‚ä¸‹é¢æ˜¯è¿™ä¸ªç®—æ³•çš„å®žçŽ°:

```go
// BFS å¹¿åº¦ä¼˜å…ˆéåŽ†å›¾è¿­ä»£å™¨ï¼ŒéåŽ†è¿‡ç¨‹ä¸­æ£€æŸ¥å›¾æ˜¯å¦æœ‰çŽ¯
// go1.23ä¹‹åŽï¼Œå¯ä»¥è€ƒè™‘æ”¹ä¸ºè¿”å›žä¸€ä¸ªæ ‡å‡†çš„è¿­ä»£å™¨ iter.Seq
func (g *Graph) BFS(walker Walker) error {
    var visitedNodesNum int
    inDegrees := make(map[Node]int, len(g.Nodes))
    for _, n := range g.Nodes {
        inDegrees[n] = 0
    }

    for _, to := range g.Edges {
        for _, n := range to {
            inDegrees[n]++
        }
    }
    var zeroDegreeNodes []Node
    for _, v := range g.Nodes {
        if inDegrees[v] == 0 {
            zeroDegreeNodes = append(zeroDegreeNodes, v)
        }
    }

    for len(zeroDegreeNodes) > 0 {
        curNode := zeroDegreeNodes[0]
        zeroDegreeNodes = zeroDegreeNodes[1:]
        if err := walker(curNode); err != nil {
            return err
        }
        visitedNodesNum++
        for _, to := range g.Edges[curNode] {
            inDegrees[to]--
            if inDegrees[to] == 0 {
                zeroDegreeNodes = append(zeroDegreeNodes, to)
            }
        }
    }
    // check circle
    if visitedNodesNum < len(g.Nodes) {
        var circleNodes []string
        for n, inDegree := range inDegrees {
            if inDegree != 0 {
                circleNodes = append(circleNodes, n.Name())
            }
        }
        sort.Slice(circleNodes, func(i, j int) bool {
            return circleNodes[i] < circleNodes[j]
        })
        return fmt.Errorf("graph has circle in nodes:%v", circleNodes)
    }

    return nil
}
```

### 2.2 è°ƒåº¦å™¨çš„å®žçŽ°

#### 2.2.1 è°ƒåº¦å™¨å®šä¹‰

æœ‰äº†å›¾ç»“æž„çš„æ”¯æ’‘ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹è®¾è®¡è°ƒåº¦å™¨äº†ã€‚æƒ³æƒ³çœ‹ï¼Œæˆ‘ä»¬çš„è°ƒåº¦å™¨ä¸­éœ€è¦æœ‰å“ªäº›å±žæ€§ï¼Ÿé¦–å…ˆéœ€è¦åŒ…å«ä¸€ä¸ªå›¾æ•°æ®ç»“æž„: `dag *DAG`,å…¶æ¬¡æˆ‘ä»¬éœ€è¦ä¸€äº›å¹¶å‘çš„æŽ§åˆ¶ï¼Œéœ€è¦å¼•å…¥`sync.WaitGroup`å’Œ`sync.Mutex`ï¼Œç„¶åŽæˆ‘ä»¬éœ€è¦ä¸€ä¸ªçŠ¶æ€é‡æ¥æ ‡è®°æˆ‘ä»¬çš„å›¾å·²ç»æž„å»ºå®Œæˆ:`sealed bool`,ç„¶åŽæˆ‘ä»¬éœ€è¦æ„ŸçŸ¥åˆ°ä»»åŠ¡å› ä¸ºæŸäº›åŽŸå› æå‰ç»“æŸäº†ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨channel: `done chan error`åŠ ä¸Šä¸€äº›å…¶ä»–çš„å±žæ€§å°±ç»„æˆçš„æˆ‘ä»¬çš„è°ƒåº¦å™¨å®šä¹‰:

```go
// Scheduler simple scheduler for typed tasks
type Scheduler[T any] struct {
    dag         *Graph
    nodes       map[string]*node[T]
    swg         *sync.WaitGroup
    lock        sync.Mutex
    err         error
    sealed      bool
    done        chan error
}
```

#### 2.2.2 ä»»åŠ¡å®šä¹‰

ä»»åŠ¡å°±æ˜¯æˆ‘ä»¬è¦è°ƒåº¦çš„å…·ä½“æ´»åŠ¨ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡é¦–å…ˆéœ€è¦ä¸€ä¸ªå”¯ä¸€çš„`Name`ï¼Œè€Œä¸”ç”±äºŽä»»åŠ¡æ˜¯æœ‰ä¾èµ–å…³ç³»çš„ï¼Œä»»åŠ¡éœ€è¦å£°æ˜Žå…¶å‰é©±èŠ‚ç‚¹`Dependencies`éƒ½æœ‰å“ªäº›ï¼Œæœ€åŽä»»åŠ¡éœ€è¦å®šä¹‰å…¶å…·ä½“è¦æ‰§è¡Œçš„å·¥ä½œ`Execute`,äºŽæ˜¯æˆ‘ä»¬å¾—åˆ°äº†ä»»åŠ¡çš„æŽ¥å£å®šä¹‰:

```go
// Task is the interface all your tasks should implement
type Task[T any] interface {
    Name() string
    Dependencies() []string
    Execute(context.Context, T) error
}
```

ä¸ºäº†æ–¹ä¾¿ä»»åŠ¡è°ƒåº¦ï¼Œæˆ‘ä»¬å®šä¹‰è°ƒåº¦å™¨ä¸­éœ€è¦ç”¨åˆ°çš„èŠ‚ç‚¹ç±»åž‹`node`ï¼š

```go
type node[T any] struct {
    ds       *Scheduler[T]
    next     []*node[T]
    task     Task[T]
}
```

#### 2.2.3 æäº¤ä»»åŠ¡

æˆ‘ä»¬çš„è°ƒåº¦å™¨éœ€è¦èƒ½æŽ¥å—ä»»åŠ¡çš„æäº¤ï¼Œå¹¶åœ¨ä»»åŠ¡æäº¤çš„æ—¶å€™åšä¸€äº›æ£€æŸ¥ï¼Œå¦‚æ£€æŸ¥è°ƒåº¦å™¨æ˜¯å¦å·²ç»å¯†å°`sealed`ã€ä»»åŠ¡æ˜¯å¦é‡å¤å­˜åœ¨ç­‰ï¼Œå¹¶å®žé™…æäº¤ä¸ºæˆ‘ä»¬è‡ªå®šä¹‰çš„nodeç±»åž‹ï¼š

```go
// Submit provide typed task to scheduler, all task should implement interface Task
func (d *Scheduler[T]) Submit(tasks ...Task[T]) error {
    if d.sealed {
        return ErrSealed
    }
    for _, task := range tasks {
        if task == nil {
            d.err = ErrNilTask
            return d.err
        }
        if _, has := d.nodes[task.Name()]; has {
            d.err = ErrTaskExist
            return d.err
        }
        n := &node[T]{task: task, ds: d}
        d.dag.AddNode(n)
        d.nodes[task.Name()] = n
    }
    return nil
}
```

#### 2.2.4 ä»»åŠ¡è°ƒåº¦æ‰§è¡Œ

ç»ˆäºŽåˆ°æœ€å…³é”®çš„ä¸€æ­¥äº†ï¼Œå½“æ‰€æœ‰ä»»åŠ¡éƒ½æäº¤å®Œæˆï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®ä»»åŠ¡çš„ä¾èµ–å…³ç³»å¼€å§‹è°ƒåº¦ä»»åŠ¡å¹¶å‘æ‰§è¡Œäº†ã€‚é¦–å…ˆéœ€è¦å…ˆå°†è°ƒåº¦å™¨å¯†å°èµ·æ¥`sealed`ï¼Œç„¶åŽæ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡å£°æ˜Žçš„ä¾èµ–èŠ‚ç‚¹éƒ½å­˜åœ¨ï¼ŒåŠå…¶å®ƒä»¬æž„æˆçš„DAGæ˜¯å¦æ˜¯æ— çŽ¯çš„ã€‚

ç„¶åŽæˆ‘ä»¬ä»Žå…¥åº¦ä¸º0çš„èŠ‚ç‚¹é›†åˆå¼€å§‹ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰ä»»ä½•å‰ç½®ä¾èµ–ï¼Œå¼€å§‹å¹¶å‘æ‰§è¡Œï¼Œè¿™åœ¨goè¯­è¨€ä¸­ç›¸å½“å®¹æ˜“ã€‚åªéœ€è¦`waitGoup.Add`ï¼Œ`waitGroup.Wait`å³å¯ã€‚å°±åƒæˆ‘ä»¬ä¹‹å‰éåŽ†DAGä¸€æ ·ï¼Œé‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œå³å¯å°†æˆ‘ä»¬çš„å›¾è°ƒåº¦æ‰§è¡Œå®Œæ¯•ã€‚è¿™é‡Œä¸ºäº†æ•ˆçŽ‡ï¼Œæˆ‘ä»¬ä¸ç›´æŽ¥è°ƒç”¨Graphä¸­å®šä¹‰å¥½çš„BFSæ–¹æ³•ï¼Œè€Œæ˜¯å°†æ— çŽ¯æ£€æŸ¥/ä»»åŠ¡è°ƒåº¦åˆå¹¶èµ·æ¥ï¼Œç”¨ä¸€ä¸ªæ–¹æ³•æ¥æ‰§è¡Œã€‚

ä»»åŠ¡æ‰§è¡Œä¸­ä¸€èˆ¬éƒ½éœ€è¦æœ‰å‚æ•°çš„è¾“å…¥ä»¥åŠå„ä¸ªèŠ‚ç‚¹ä»»åŠ¡çš„è¾“å‡ºæ”¶é›†ï¼Œæˆ‘ä»¬è¿™é‡Œä½¿ç”¨äº†èŒƒåž‹å‚æ•°`x`æ¥è¡¨ç¤ºç»Ÿä¸€çš„æ‰§è¡ŒçŽ¯å¢ƒï¼Œå„ä¸ªä»»åŠ¡èŠ‚ç‚¹å¯ä»¥ä»Žä¸­è¯»å–ç›¸å…³å‚æ•°æˆ–è€…å…¶ä»–å‰é©±èŠ‚ç‚¹çš„è¾“å‡ºï¼Œä¹Ÿå¯ä»¥åœ¨å…¶ä¸­ä¿å­˜å½“å‰èŠ‚ç‚¹çš„æ‰§è¡Œç»“æžœç­‰ï¼Œä¸è¿‡è¿™é‡Œéœ€è¦æ³¨æ„æŽ§åˆ¶å¹¶å‘é—®é¢˜:

```go
// Run start all tasks and block till all of them done or meet critical err
func (d *Scheduler[T]) Run(ctx context.Context, x T) error {
    if d.err != nil {
        return d.err
    }
    d.sealed = true
    for _, n := range d.nodes {
        for _, name := range n.task.Dependencies() {
            pre, ok := d.nodes[name]
            if !ok {
                return fmt.Errorf("dag:%w: task :%s's dependency:%s not found", ErrTaskNotExist, n.Name(), name)
            }
            d.dag.AddEdge(pre, n)
            pre.next = append(pre.next, n)
        }
    }
    var visitedNodesNum int
    // init nodes inDegrees
    inDegrees := make(map[string]int, len(d.nodes))
    for _, n := range d.nodes {
        inDegrees[n.Name()] = 0
    }
    for _, to := range d.dag.Edges {
        for _, n := range to {
            inDegrees[n.Name()]++
        }
    }
    var toStartNodes []*node[T]
    for name, inDegree := range inDegrees {
        curN := d.nodes[name]
        if inDegree == 0 {
            toStartNodes = append(toStartNodes, curN)
        }
    }
    for len(toStartNodes) > 0 {
        d.swg = new(sync.WaitGroup)
        d.swg.Add(len(toStartNodes))
        for _, n := range toStartNodes {
            n.start(ctx, x)
            visitedNodesNum++
        }
        d.swg.Wait()
        if d.err != nil {
            return d.err
        }
        pre := toStartNodes
        toStartNodes = []*node[T]{}
        for _, startNode := range pre {
            for _, n := range startNode.next {
                inDegrees[n.Name()]--
                if inDegrees[n.Name()] == 0 {
                    toStartNodes = append(toStartNodes, n)
                }
            }
        }
    }
    // check circle
    if visitedNodesNum < len(d.dag.Nodes) {
        var circleNodes []string
        for n, inDegree := range inDegrees {
            if inDegree != 0 {
                circleNodes = append(circleNodes, n)
            }
        }
        sort.Slice(circleNodes, func(i, j int) bool {
            return circleNodes[i] < circleNodes[j]
        })
        return fmt.Errorf("dag:graph has circle in nodes:%v", circleNodes)
    }

    return nil
}
```

`node.Start`æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¯åŠ¨æ–°çš„goroutineï¼Œæ¥æ‰§è¡Œä»»åŠ¡å®šä¹‰çš„Executeæ–¹æ³•ã€‚è®°å¾—æ–°çš„goroutineåç¨‹ä¸­ä¸è¦å¿˜è®°æ•èŽ·å¯èƒ½å‡ºçŽ°çš„panicã€‚

## ä¸‰ã€ä½¿ç”¨ç¤ºä¾‹

å®žçŽ°è°ƒåº¦å™¨ä¹‹åŽï¼Œæˆ‘ä»¬å¯ä»¥æ–¹ä¾¿çš„å®šä¹‰è‡ªå·±çš„ä»»åŠ¡ï¼šB,Cä¾èµ–Aå®Œæˆï¼Œå¹¶å°†ä»»åŠ¡æäº¤ç»™è°ƒåº¦å™¨æ‰§è¡Œï¼š

```go
// define taskA type
type task struct{name string, deps []string}
func (t task) Name() string {return t.name}
func (t task) Dependencies() []string {return t.deps}
func (t task) Execute(ctx context.Context, runCtx *sync.Map) error {return nil}

// taskB, taskC ....as the same

ds := NewScheduler[*sync.Map]()
ds.Submit(task{name:"A"})
ds.Submit(task{name:"B",deps:[]string{"A"}})
ds.Submit(task{name:"C",deps:[]string{"A"}})
err := ds.Run(context.Background(), &sync.Map{})
```

## å››ã€ç»“è¯­

å¥½äº†ï¼Œåˆ©ç”¨goè¯­è¨€ï¼Œä½ å¯ä»¥è‡ªå·±è½»æ¾å®žçŽ°ä¸€ä¸ªDAGè°ƒåº¦å™¨ã€‚è¿™æ˜¯æˆ‘å®žçŽ°çš„[DAGè°ƒåº¦å™¨](https://github.com/ycl2018/dag-run)ï¼šè¿™ä¸ªè°ƒåº¦å™¨è¿˜æ”¯æŒå…¶ä»–é¢å¤–çš„Featureï¼š

- æ”¯æŒèŒƒåž‹
- ç›´æŽ¥æäº¤å‡½æ•°ä»»åŠ¡
- æ”¯æŒæ³¨å…¥æ‹¦æˆªå™¨
- æ”¯æŒåˆ†æ”¯ä»»åŠ¡
- æ”¯æŒä»»åŠ¡è¶…æ—¶é‡è¯•é…ç½®ç­‰

æœ€åŽæ„Ÿè°¢é˜…è¯»ï¼Œæ¬¢è¿Žä½¿ç”¨ã€åé¦ˆã€ä¸è¦å¿˜è®°ç»™ä¸ªå°æ˜Ÿæ˜Ÿæ”¯æŒä¸€ä¸‹ï¼ðŸ˜Š
